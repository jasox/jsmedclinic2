<!DOCTYPE composition PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  
<ui:composition xmlns="http://www.w3.org/1999/xhtml"
                xmlns:ui="http://java.sun.com/jsf/facelets"
                xmlns:f="http://java.sun.com/jsf/core"
                xmlns:h="http://java.sun.com/jsf/html"
                xmlns:s="http://jboss.org/seam/faces"
                xmlns:m="http://java.sun.com/jsf/composite/components/model"
                template="/WEB-INF/layout/template.xhtml">

  <!-- Parametr id przekazywany jest ze strony `search.xhtml`
       po wywoÅ‚aniu bookingAgent.selectHotel(_hotelId) -
       Ustawiany jest parametr `hotelSelection` w BookingAgent -->
  <ui:define name="metadata">
    <f:metadata>
      <f:viewParam name="id" value="#{_hotelId}"/>
      <s:viewAction 
        action="#{bookingAgent.selectHotel(_hotelId)}"/>
    </f:metadata>
  </ui:define>

  <ui:define name="content">

    <div class="section">
      <h1>Hotel Details</h1>
    </div>

    <div class="section">
      <m:displayHotel value="#{hotel}"/>

      <div class="buttonBox">
        <h:panelGroup rendered="#{not identity.loggedIn}">
          <p style="text-align: center;">
            You must login to book a hotel.
          </p>
        </h:panelGroup>
        <h:form id="actions">
          <h:commandButton 
            id="bookHotel" 
            action="#{bookingAgent.bookHotel}" 
            value="Book Hotel"
            rendered="#{identity.loggedIn}"/>
          #{' '}
          <h:commandButton 
            id="cancel" 
            action="#{bookingAgent.cancel}" 
            value="Return to Search" 
            immediate="true"/>
        </h:form>
      </div>

    </div>

  </ui:define>

  <ui:define name="sidebar">
    <div class="content">
      <h1>Don't kill your database</h1>

      <p>
        Keeping conversational state in memory in the middle tier is a great
        way to improve your application's scalability. <br/>
        It saves hitting the database every time we refresh a page, to re-read 
        the data we were just looking at five seconds ago. <br/>
        By using Seam's conversation context, we get a natural cache of data 
        associated with the what the user is currently doing. <br/>
        By nature, this cache has a more efficient eviction policy than the MRU-type 
        algorithms used by a typical second-level data cache in an O/R mapping engine 
        like Hibernate (at least for some kinds of data). <br/>
        Of course, you should use a clever combination of second-level caching 
        and conversational data caching to achieve the best performance for your application.
      </p>
      <!--
      
      -->
    </div>
  </ui:define>

</ui:composition>
